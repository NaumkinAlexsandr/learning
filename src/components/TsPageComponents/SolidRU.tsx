import React from "react";
import Table from "@mui/material/Table";
import TableBody from "@mui/material/TableBody";
import TableOneCol from "../../core/TableOneCol.tsx";
import ButtonExampleTwoCol from "../../core/ButtonExampleTwoCol.tsx";
import { solidS, solidO, solidL, solidI, solidD } from "./TsConstPre.tsx";
import { getFormatedText } from "../../core/getFormatedText.tsx";

export default function SolidRU() {
  return (
    <>
      <Table id="ts_solid">
        <TableBody>
          <TableOneCol text={<h2>SOLID.</h2>} />
          <TableOneCol
            text={
              <p>
                SOLID - это архитектурный труд, который используется для
                создание программного обеспечения. Этот принцип включает в себя
                5 принципов, помогающих создавать более удобные и легко
                расширительные программы.
              </p>
            }
          />
          <TableOneCol
            text={
              <p>
                <b>
                  Single Responsibility Principle (Принцип одноразового
                  использование)
                </b>
                -этот принцип определяет, что каждая переменная или метод должен
                иметь только одну область исполнения. Таким образом, каждая
                переменная или метод должен иметь только одну независимую
                логику.
              </p>
            }
          />
          <ButtonExampleTwoCol
            titleButtonExample={"Пример S"}
            title={
              <>
                <pre>
                  <code>{solidS}</code>
                </pre>
                <p id="formated-text">
                  Данный код представляет простую реализацию системы библиотеки
                  и пользователей.
                  <ul>
                    В коде определены следующие интерфейсы:
                    <li>
                      IBook: содержит свойства title, author и status, которые
                      описывают книгу.
                    </li>
                    <li>
                      ILibrary: содержит свойство books, которое представляет
                      массив книг.
                    </li>
                    <li>
                      IUser: содержит свойства name и phone, которые описывают
                      пользователя.
                    </li>
                  </ul>
                  Класс Book реализует интерфейс IBook и содержит конструктор, а
                  также методы getTitle() и getAuthor() , возвращающие
                  соответствующие значения свойств.
                  <br />
                  Класс Library реализует интерфейс ILibrary и содержит
                  конструктор, а также методы addNewBook() , removeOldBook() ,
                  borrowBook() и returnBook() . Эти методы добавляют новую книгу
                  в библиотеки, удаляющие книгу из библиотеки, издающие книгу
                  пользователю и возвращают книгу в библиотеку соответственно.
                  <br />
                  Класс User реализует интерфейс IUser и содержит конструктор, а
                  также методы borrowBook() и returnBook(). Эти методы позволяют
                  пользователю брать книгу из библиотеки и возвращать ее вспять.
                  <br />
                  После этого создаются объекты Book, Library и User, и
                  осуществляются различные операции с библиотекой и
                  пользователями, которые выводятся в консоль.
                </p>
              </>
            }
          />
          <TableOneCol
            text={
              <p>
                <b>Open/Closed Principle (Принцип открытой/закрытой )</b> - этот
                принцип определяет, что код должен быть открыт для расширения,
                но закрытым для смены. Таким образом, переменные или методы
                должны иметь возможность быть добавлены или изменены без
                изменения внутреннего кода.
              </p>
            }
          />
          <ButtonExampleTwoCol
            titleButtonExample={"Пример O"}
            title={
              <>
                <pre>
                  <code>{solidO}</code>
                </pre>
                <p id="formated-text">
                  Данный код представляет интерфейсы и классы для работы с
                  геометрические фигуры.
                  <ul>
                    В коде определены следующие интерфейсы:
                    <li>
                      IGeometricFigure : содержит свойства x и y , которые
                      представляют координаты фигуры, а также метод draw() ,
                      отвечающий за отображение фигуры.
                    </li>
                    <li>
                      ICircle: расширяет интерфейс IGeometricFigure и содержит
                      дополнительное свойство radius , представляющее радиус
                      круг.
                    </li>
                    <li>
                      IRectangle: расширяет интерфейс IGeometricFigure и
                      содержит дополнительные свойства width и height,
                      представляющие ширину и высоту прямоугольника.
                    </li>
                    <li>
                      ITriangle: расширяет интерфейс IGeometricFigure и содержит
                      дополнительные свойства width и height, представляющие
                      ширину и высоту треугольника.
                    </li>
                    <li>
                      IEllipse: расширяет интерфейс IGeometricFigure и содержит
                      дополнительное свойство radius , представляющее радиус
                      эллипса.
                    </li>
                  </ul>
                  Абстрактный класс Shape реализует интерфейс IGeometricFigure и
                  содержит конструктор, принимающий координаты фигуры. Класс
                  также имеет пустой метод draw() , который может быть
                  переопределен в производных классах.
                  <br />
                  Классы Circle, Rectangle, Triangle и Ellipse наследуют класс
                  Shape и реализуют соответствующие интерфейсы. Каждый из этих
                  классов имеет конструктор, принимающий координаты фигуры и
                  дополнительные параметры, такие как радиус, ширина и высота.
                  Классы также имеют метод draw() , выводящий сообщение о
                  рисунок фигуры с соответствующими параметрами.
                  <br />В конце кода создаются объекты каждого типа фигуры
                  (круг, прямоугольник, треугольник, эллипс) и вызываемые их
                  методы draw() , выводящие сообщения в консоль.
                </p>
              </>
            }
          />
          <TableOneCol
            text={
              <p>
                <b>Liskov Substitution Principle (Принцип подстановки Лисса)</b>
                - этот принцип определяет, что объекты средствами которых
                выполняются операции должны иметь возможность заменять объекты
                средствами которых выполняются операции. Таким образом, классы
                должны иметь возможность заменять друг друга.
              </p>
            }
          />
          <ButtonExampleTwoCol
            titleButtonExample={"Пример L"}
            title={
              <>
                <pre>
                  <code>{solidL}</code>
                </pre>
                <p id="formated-text">
                  Данный код представляет интерфейсы и классы для работы с
                  геометрические фигуры.
                  <ul>
                    В коде определены следующие интерфейсы:
                    <li>
                      IGeometricFigure: содержит свойства color и name, которые
                      представляют цвет и название фигуры, а также метод
                      getArea() , возвращающий площадь фигуры.
                    </li>
                    <li>
                      ICircle: расширяет интерфейс IGeometricFigure и содержит
                      дополнительное свойство radius , представляющее радиус
                      круг.
                    </li>
                    <li>
                      IRectangle: расширяет интерфейс IGeometricFigure и
                      содержит дополнительные свойства width и height,
                      представляющие ширину и высоту прямоугольника.
                    </li>
                    <li>
                      ITriangle: расширяет интерфейс IGeometricFigure и содержит
                      дополнительные свойства width и height, представляющие
                      ширину и высоту треугольника.
                    </li>
                  </ul>
                  Абстрактный класс Shape реализует интерфейс IGeometricFigure и
                  содержит конструктор, принимающий цвет и название фигуры.
                  Класс также имеет абстрактный метод getArea() , который должен
                  быть переопределен в производных классах.
                  <br />
                  Классы Circle, Rectangle, Triangle наследуют класс Shape и
                  реализуют соответствующие интерфейсы. Каждый из этих классов
                  имеет конструктор, принимающий название, цвет и дополнительные
                  параметры, такие как радиус, ширина и высота. Классы также
                  имеют метод getArea() , который вычисляет площадь фигуры в
                  зависимости от их параметров
                  <br />
                  Функция printArea() принимает объект, реализующий интерфейс
                  IGeometricFigure и выводит в консоль название фигуры и ее
                  площадь, вызывая метод getArea().
                  <br />В конце кода создаются объекты каждого типа фигуры
                  (круг, прямоугольник, треугольник) и вызываемая функция
                  printArea() , выводящая площадь каждой фигуры в консоль.
                </p>
              </>
            }
          />
          <TableOneCol
            text={
              <p>
                <b>
                  Interface Segregation Principle (Принцип сегментации
                  интерфейсов)
                </b>
                - этот принцип определяет, что классы должны иметь разные
                интерфейсы, а не один интерфейс для всех методов. Таким образом,
                классы должны иметь возможность иметь разные функции.
              </p>
            }
          />
          <ButtonExampleTwoCol
            titleButtonExample={"Пример I"}
            title={
              <>
                <pre>
                  <code>{solidI}</code>
                </pre>
                <p id="formated-text">
                  Данный код представляет систему управления задачами. В нем
                  определенные интерфейсы и классы, позволяющие создавать,
                  назначать и выполнять задачи.
                  <ul>
                    В коде определены следующие перечисления (enum):
                    <li>
                      UserPosition : содержит значение для позиций пользователей
                      - разработчик (DEVELOPER) и менеджер (MANAGER).
                    </li>
                    <li>
                      TaskStatus: содержит значение для статусов задач - "TODO"
                      (не выполнено), "IN_PROGRESS" (в процессе выполнения) и
                      "COMPLETED" (выполнено).
                    </li>
                  </ul>
                  <ul>
                    В коде определены интерфейсы:
                    <li>
                      IUser: содержит свойства для идентификатора пользователя
                      (id), имени (name) и позиции (position).
                    </li>
                    <li>
                      ITask: содержит свойства для идентификатора задачи (id),
                      названия (title), статуса (status) и исполнителя
                      (executor).
                    </li>
                    <li>
                      ICreateTask : содержит метод createTask(title: string,
                      executor: IUser) , создающий новую задачу.
                    </li>
                    <li>
                      IAssignTask : содержит метод assignTask(task: ITask,
                      executor: IUser) , назначающий исполнителя для задания.
                    </li>
                    <li>
                      ICompleteTask : содержит метод completeTask(task: ITask) ,
                      который обозначает задачу как выполненную.
                    </li>
                  </ul>
                  <ul>
                    Есть также классы:
                    <li>
                      Developer: реализует интерфейсы IUser и ICompleteTask и
                      представляет разработчика. Имеет метод completeTask,
                      который устанавливает статус задачи как исполненное.
                    </li>
                    <li>
                      Manager: реализует интерфейсы IUser, IAssignTask и
                      ICompleteTask и представляет менеджера. Имеет методы
                      assignTask и completeTask , которые назначают исполнителя
                      и обозначают задачу как выполненную соответственно.
                    </li>
                    <li>
                      TaskService : реализует интерфейсы ICreateTask ,
                      IAssignTask и ICompleteTask и представляет сервис
                      управление задачами. Имеет методы для создания, назначение
                      и обозначение задач как выполненных.
                    </li>
                  </ul>
                  В конце кода создаются объекты разработчика, менеджера и
                  сервиса управления задачами Создаются несколько задач,
                  назначаются исполнители и обозначаются как исполненные.
                  Результаты выводятся в консоль.
                </p>
              </>
            }
          />
          <TableOneCol
            text={
              <p>
                <b>
                  Dependency Inversion Principle (Принцип отклонения
                  зависимостей)
                </b>
                - этот принцип определяет, что классы должны иметь низкую
                зависимость от вызовов, а не выше зависимости от других классов.
                Таким образом, классы должны иметь возможность зависеть от
                абстрактных классов или интерфейсов, а не конкретных
                соответствующих классов.
              </p>
            }
          />
          <ButtonExampleTwoCol
            titleButtonExample={"Пример D"}
            title={
              <>
                <pre>
                  <code>{solidD}</code>
                </pre>
                <p id="formated-text">
                  Данный код представляет систему обработки сообщений, которая
                  осуществляет отправку сообщений по электронной почте и SMS.
                  <ul>
                    В коде определены следующие перечисления (enum):
                    <li>
                      Service: содержит значение для типа сервиса - "email"
                      (электронная почта) и SMS.
                    </li>
                  </ul>
                  <ul>
                    В коде определены интерфейсы:
                    <li>
                      IMessage: содержит свойства для отправителя (sender),
                      получателя (receiver) и содержания (content) сообщения.
                    </li>
                    <li>
                      IMessageHandler : содержит метод handleMessage(message:
                      IMessage) , обрабатывающий сообщение.
                    </li>
                  </ul>
                  Класс Messenger представляет систему обработки сообщений.
                  Имеет частное свойство messageHandlers, которое сохраняет
                  обработчики сообщений для каждого типа получателя. Метод
                  registerHandler добавляет обработчик сообщений для
                  определенного типа получателя. Метод sendMessage отправляет
                  сообщения, перебирая все обработчики для соответствующего типа
                  получателя и вызывая их метод handleMessage.
                  <br />
                  Классы EmailService и SMSService реализуют интерфейс
                  IMessageHandler и представляют сервисы электронной почты и SMS
                  соответственно. Имеют метод handleMessage, выводящий сообщение
                  об отправке сообщения в соответствующее получателя.
                  <br />В конце кода создается объект messenger класса
                  Messenger. Создаются объекты emailService и smsService классов
                  EmailService и SMSService соответственно. Зарегистрированы
                  обработчики для типов получателей "email" и "sms". Создаются и
                  отправляется несколько сообщений.
                  <br />
                  Результаты выводятся в консоль.
                </p>
              </>
            }
          />
        </TableBody>
      </Table>
    </>
  );
}
