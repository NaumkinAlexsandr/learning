import React from "react";
import Table from "@mui/material/Table";
import TableBody from "@mui/material/TableBody";
import TableOneCol from "../../core/TableOneCol.tsx";
import ButtonExampleTwoCol from "../../core/ButtonExampleTwoCol.tsx";
import { solidS, solidO, solidL, solidI, solidD } from "./TsConstPre.tsx";
import { getFormatedText } from "../../core/getFormatedText.tsx";

export default function SolidUA() {
  return (
    <>
      <Table id="ts_solid">
        <TableBody>
          <TableOneCol text={<h2>SOLID.</h2>} />
          <TableOneCol
            text={
              <p>
                SOLID - це архітектуральна праця, яка використовується для
                створення програмного забезпечення. Цей принцип включає в себе 5
                принципів, які допомагають створювати більш зручні та легко
                розширювальні програми.
              </p>
            }
          />
          <TableOneCol
            text={
              <p>
                <b>
                  Single Responsibility Principle (Принцип одноразового
                  використання)
                </b>
                - цей принцип визначає, що кожна змінна або метод повинен мати
                тільки одну область виконання. Таким чином, кожна змінна або
                метод повинен мати тільки одну незалежну логіку.
              </p>
            }
          />
          <ButtonExampleTwoCol
            titleButtonExample={"Приклад S"}
            title={
              <>
                <pre>
                  <code>{solidS}</code>
                </pre>
                <p id="formated-text">
                  Даний код представляє просту реалізацію системи бібліотеки та
                  користувачів.
                  <ul>
                    У коді визначені наступні інтерфейси:
                    <li>
                      IBook : містить властивості title , author та status , які
                      описують книгу.
                    </li>
                    <li>
                      ILibrary : містить властивість books , яка представляє
                      масив книг.
                    </li>
                    <li>
                      IUser : містить властивості name та phone , які описують
                      користувача.
                    </li>
                  </ul>
                  Клас Book реалізує інтерфейс IBook і містить конструктор, а
                  також методи getTitle() та getAuthor() , які повертають
                  відповідні значення властивостей.
                  <br />
                  Клас Library реалізує інтерфейс ILibrary і містить
                  конструктор, а також методи addNewBook() , removeOldBook() ,
                  borrowBook() та returnBook() . Ці методи додають нову книгу до
                  бібліотеки, видаляють книгу з бібліотеки, видають книгу
                  користувачу та повертають книгу до бібліотеки відповідно.
                  <br />
                  Клас User реалізує інтерфейс IUser і містить конструктор, а
                  також методи borrowBook() та returnBook() . Ці методи
                  дозволяють користувачу брати книгу з бібліотеки та повертати
                  її назад.
                  <br />
                  Після цього створюються об'єкти Book , Library та User , і
                  здійснюються різні операції з бібліотекою та користувачами,
                  які виводяться в консоль.
                </p>
              </>
            }
          />
          <TableOneCol
            text={
              <p>
                <b>Open/Closed Principle (Принцип відкритої/закритої)</b> - цей
                принцип визначає, що код повинен бути відкритим для розширення,
                але закритим для зміни. Таким чином, змінні або методи повинні
                мати можливість бути додані або змінені без зміни внутрішнього
                коду.
              </p>
            }
          />
          <ButtonExampleTwoCol
            titleButtonExample={"Приклад O"}
            title={
              <>
                <pre>
                  <code>{solidO}</code>
                </pre>
                <p id="formated-text">
                  Даний код представляє інтерфейси та класи для роботи з
                  геометричними фігурами.
                  <ul>
                    У коді визначені наступні інтерфейси:
                    <li>
                      IGeometricFigure : містить властивості x та y , які
                      представляють координати фігури, а також метод draw() ,
                      який відповідає за відображення фігури.
                    </li>
                    <li>
                      ICircle : розширює інтерфейс IGeometricFigure і містить
                      додаткову властивість radius , яка представляє радіус
                      кола.
                    </li>
                    <li>
                      IRectangle : розширює інтерфейс IGeometricFigure і містить
                      додаткові властивості width та height , які представляють
                      ширину та висоту прямокутника.
                    </li>
                    <li>
                      ITriangle : розширює інтерфейс IGeometricFigure і містить
                      додаткові властивості width та height , які представляють
                      ширину та висоту трикутника.
                    </li>
                    <li>
                      IEllipse : розширює інтерфейс IGeometricFigure і містить
                      додаткову властивість radius , яка представляє радіус
                      еліпса.
                    </li>
                  </ul>
                  Абстрактний клас Shape реалізує інтерфейс IGeometricFigure та
                  містить конструктор, який приймає координати фігури. Клас
                  також має пустий метод draw() , який може бути перевизначений
                  в похідних класах.
                  <br />
                  Класи Circle , Rectangle , Triangle та Ellipse успадковують
                  клас Shape та реалізують відповідні інтерфейси. Кожен з цих
                  класів має конструктор, який приймає координати фігури та
                  додаткові параметри, такі як радіус, ширина та висота. Класи
                  також мають метод draw() , який виводить повідомлення про
                  малювання фігури з відповідними параметрами.
                  <br />У кінці коду створюються об'єкти кожного типу фігури
                  (коло, прямокутник, трикутник, еліпс) і викликаються їх методи
                  draw() , які виводять повідомлення в консоль.
                </p>
              </>
            }
          />
          <TableOneCol
            text={
              <p>
                <b>Liskov Substitution Principle (Принцип подстановки Лисса)</b>
                - цей принцип визначає, що об'єкти засобами яких виконуються
                операції повинні мати можливість замінювати об'єкти засобами
                яких виконуються операції. Таким чином, класи повинні мати
                можливість замінювати один одного.
              </p>
            }
          />
          <ButtonExampleTwoCol
            titleButtonExample={"Приклад L"}
            title={
              <>
                <pre>
                  <code>{solidL}</code>
                </pre>
                <p id="formated-text">
                  Даний код представляє інтерфейси та класи для роботи з
                  геометричними фігурами.
                  <ul>
                    У коді визначені наступні інтерфейси:
                    <li>
                      IGeometricFigure : містить властивості color та name , які
                      представляють колір та назву фігури, а також метод
                      getArea() , який повертає площу фігури.
                    </li>
                    <li>
                      ICircle : розширює інтерфейс IGeometricFigure і містить
                      додаткову властивість radius , яка представляє радіус
                      кола.
                    </li>
                    <li>
                      IRectangle : розширює інтерфейс IGeometricFigure і містить
                      додаткові властивості width та height , які представляють
                      ширину та висоту прямокутника.
                    </li>
                    <li>
                      ITriangle : розширює інтерфейс IGeometricFigure і містить
                      додаткові властивості width та height , які представляють
                      ширину та висоту трикутника.
                    </li>
                  </ul>
                  Абстрактний клас Shape реалізує інтерфейс IGeometricFigure та
                  містить конструктор, який приймає колір та назву фігури. Клас
                  також має абстрактний метод getArea() , який повинен бути
                  перевизначений в похідних класах.
                  <br />
                  Класи Circle , Rectangle , Triangle успадковують клас Shape та
                  реалізують відповідні інтерфейси. Кожен з цих класів має
                  конструктор, який приймає назву, колір та додаткові параметри,
                  такі як радіус, ширина та висота. Класи також мають метод
                  getArea() , який обчислює площу фігури залежно від їхніх
                  параметрів.
                  <br />
                  Функція printArea() приймає об'єкт, який реалізує інтерфейс
                  IGeometricFigure , і виводить в консоль назву фігури та її
                  площу, викликаючи метод getArea() .
                  <br />У кінці коду створюються об'єкти кожного типу фігури
                  (коло, прямокутник, трикутник) і викликається функція
                  printArea() , яка виводить площу кожної фігури в консоль.
                </p>
              </>
            }
          />
          <TableOneCol
            text={
              <p>
                <b>
                  Interface Segregation Principle (Принцип сегментації
                  інтерфейсів)
                </b>
                - цей принцип визначає, що класи повинні мати різні інтерфейси,
                а не один один інтерфейс для всіх методів. Таким чином, класи
                повинні мати можливість мати різні функції.
              </p>
            }
          />
          <ButtonExampleTwoCol
            titleButtonExample={"Приклад I"}
            title={
              <>
                <pre>
                  <code>{solidI}</code>
                </pre>
                <p id="formated-text">
                  Даний код представляє систему управління завданнями. В ньому
                  визначені інтерфейси та класи, що дозволяють створювати,
                  призначати та виконувати завдання.
                  <ul>
                    У коді визначені наступні перерахування (enum):
                    <li>
                      UserPosition : містить значення для позицій користувачів -
                      розробник (DEVELOPER) та менеджер (MANAGER).
                    </li>
                    <li>
                      TaskStatus : містить значення для статусів завдань -
                      "TODO" (не виконане), "IN_PROGRESS" (в процесі виконання)
                      та "COMPLETED" (виконане).
                    </li>
                  </ul>
                  <ul>
                    У коді визначено інтерфейси:
                    <li>
                      IUser : містить властивості для ідентифікатора користувача
                      (id), імені (name) та позиції (position).
                    </li>
                    <li>
                      ITask : містить властивості для ідентифікатора завдання
                      (id), назви (title), статусу (status) та виконавця
                      (executor).
                    </li>
                    <li>
                      ICreateTask : містить метод createTask(title: string,
                      executor: IUser) , який створює нове завдання.
                    </li>
                    <li>
                      IAssignTask : містить метод assignTask(task: ITask,
                      executor: IUser) , який призначає виконавця для завдання.
                    </li>
                    <li>
                      ICompleteTask : містить метод completeTask(task: ITask) ,
                      який позначає завдання як виконане.
                    </li>
                  </ul>
                  <ul>
                    Є також класи:
                    <li>
                      Developer : реалізує інтерфейси IUser та ICompleteTask і
                      представляє розробника. Має метод completeTask , який
                      встановлює статус завдання як виконане.
                    </li>
                    <li>
                      Manager : реалізує інтерфейси IUser , IAssignTask та
                      ICompleteTask і представляє менеджера. Має методи
                      assignTask та completeTask , які призначають виконавця та
                      позначають завдання як виконане відповідно.
                    </li>
                    <li>
                      TaskService : реалізує інтерфейси ICreateTask ,
                      IAssignTask та ICompleteTask і представляє сервіс
                      управління завданнями. Має методи для створення,
                      призначення та позначення завдань як виконаних.
                    </li>
                  </ul>
                  У кінці коду створюються об'єкти розробника, менеджера та
                  сервісу управління завданнями. Створюються кілька завдань,
                  призначаються виконавці та позначаються як виконані.
                  Результати виводяться в консоль.
                </p>
              </>
            }
          />
          <TableOneCol
            text={
              <p>
                <b>
                  Dependency Inversion Principle (Принцип відхилення
                  залежностей)
                </b>
                - цей принцип визначає, що класи повинні мати низьку залежність
                від викликів, а не вище залежність від інших класів. Таким
                чином, класи повинні мати можливість залежити від абстрактних
                класів або інтерфейсів, а не від конкретних відповідних класів.
              </p>
            }
          />
          <ButtonExampleTwoCol
            titleButtonExample={"Приклад D"}
            title={
              <>
                <pre>
                  <code>{solidD}</code>
                </pre>
                <p id="formated-text">
                  Даний код представляє систему обробки повідомлень, яка
                  здійснює відправку повідомлень через електронну пошту та SMS.
                  <ul>
                    У коді визначені наступні перерахування (enum):
                    <li>
                      Service : містить значення для типу сервісу - "email"
                      (електронна пошта) та "sms".
                    </li>
                  </ul>
                  <ul>
                    У коді визначені інтерфейси:
                    <li>
                      IMessage : містить властивості для відправника (sender),
                      отримувача (receiver) та змісту (content) повідомлення.
                    </li>
                    <li>
                      IMessageHandler : містить метод handleMessage(message:
                      IMessage) , який обробляє повідомлення.
                    </li>
                  </ul>
                  Клас Messenger представляє систему обробки повідомлень. Має
                  приватну властивість messageHandlers , яка зберігає обробники
                  повідомлень для кожного типу отримувача. Метод registerHandler
                  додає обробник повідомлень для певного типу отримувача. Метод
                  sendMessage відправляє повідомлення, перебираючи всі обробники
                  для відповідного типу отримувача та викликаючи їх метод
                  handleMessage .
                  <br />
                  Класи EmailService та SMSService реалізують інтерфейс
                  IMessageHandler і представляють сервіси електронної пошти та
                  SMS відповідно. Мають метод handleMessage , який виводить
                  повідомлення про відправку повідомлення до відповідного
                  отримувача.
                  <br />У кінці коду створюється об'єкт messenger класу
                  Messenger . Створюються об'єкти emailService та smsService
                  класів EmailService та SMSService відповідно. Зареєстровані
                  обробники для типів отримувачів "email" та "sms". Створюються
                  та відправляються декілька повідомлень.
                  <br />
                  Результати виводяться в консоль.
                </p>
              </>
            }
          />
        </TableBody>
      </Table>
    </>
  );
}
